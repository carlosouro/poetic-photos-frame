<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Poetic Memories</title>
    <link href="https://fonts.googleapis.com/css2?family=Merriweather:ital,wght@0,300;0,400;1,300&family=Montserrat:wght@400;600&display=swap" rel="stylesheet">
    
    <style>
        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%;
            background-color: #000; color: #fff; overflow: hidden;
            font-family: 'Merriweather', serif; user-select: none;
            cursor: none; 
        }

        #app { position: relative; width: 100vw; height: 100vh; }

        /* PHOTO LAYER */
        #photo-container {
            width: 100%; height: 100%; display: flex;
            justify-content: center; align-items: center; background: #000;
        }
        #main-photo {
            max-width: 100%; max-height: 100%; object-fit: contain; 
            opacity: 0; transition: opacity 1.5s ease-in-out;
        }

        /* TEXT OVERLAY */
        #text-overlay {
            position: absolute; bottom: 0; left: 0; width: 100%; min-height: 25vh; 
            background: linear-gradient(to top, rgba(0,0,0,0.95) 0%, rgba(0,0,0,0.6) 60%, rgba(0,0,0,0) 100%);
            display: flex; flex-direction: column; justify-content: flex-end; 
            align-items: center; padding-bottom: 20px; z-index: 10; pointer-events: none;
        }
        #content-wrapper { width: 80%; text-align: center; margin-bottom: 30px; pointer-events: none; }
        #poem-text {
            font-size: 1.8rem; font-style: italic; line-height: 1.4; color: #f0f0f0;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8); opacity: 0; transition: opacity 2s ease-in-out 0.5s;
        }
        #author-text {
            font-family: 'Montserrat', sans-serif; font-size: 0.9rem; color: #aaa;
            text-transform: uppercase; letter-spacing: 2px; margin-top: 15px;
            opacity: 0; transition: opacity 2s ease-in-out 0.8s;
        }
        #date-display {
            position: absolute; bottom: 25px; right: 30px;
            font-family: 'Montserrat', sans-serif; font-size: 0.85rem; color: #888;
            letter-spacing: 1px; opacity: 0; transition: opacity 2s ease-in-out 1s;
        }

        /* TOP RIGHT HEART ICON */
        #quick-fav {
            position: absolute; top: 30px; right: 30px; z-index: 60;
            width: 40px; height: 40px; cursor: pointer;
            opacity: 0.7; transition: transform 0.2s, opacity 0.2s;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.5));
        }
        #quick-fav:active { transform: scale(0.9); }
        #quick-fav svg { width: 100%; height: 100%; }
        
        .heart-outline { fill: none; stroke: #fff; stroke-width: 2; }
        .heart-fill { fill: #e91e63; stroke: #e91e63; stroke-width: 2; display: none; }
        
        /* Active state shows the filled heart */
        #quick-fav.active .heart-outline { display: none; }
        #quick-fav.active .heart-fill { display: block; }

        /* FULL SCREEN LOADER */
        #loader-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.7); 
            z-index: 3000; 
            display: flex; justify-content: center; align-items: center;
            opacity: 0; pointer-events: none; transition: opacity 0.3s;
        }
        #loader-overlay.visible { opacity: 1; pointer-events: auto; }
        #loader-text {
            font-family: 'Montserrat', sans-serif; font-size: 1.5rem; letter-spacing: 2px; color: #fff;
        }

        /* CLICK ZONES */
        .click-zone { position: absolute; top: 0; height: 100%; z-index: 50; }
        #zone-left { left: 0; width: 30%; cursor: w-resize; }
        #zone-center { left: 30%; width: 40%; cursor: pointer; }
        #zone-right { left: 70%; width: 30%; cursor: e-resize; }

        /* MENU STYLES */
        #menu-overlay, #delete-confirm-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); z-index: 2000;
            display: flex; justify-content: center; align-items: center;
            backdrop-filter: blur(5px); opacity: 0; pointer-events: none;
            transition: opacity 0.3s ease;
            cursor: default;
        }
        .overlay-visible { opacity: 1 !important; pointer-events: auto !important; }

        #menu-box {
            background: #1a1a1a; padding: 25px; border-radius: 15px; border: 1px solid #333;
            display: flex; flex-direction: column; gap: 15px; min-width: 280px;
            text-align: center; box-shadow: 0 10px 25px rgba(0,0,0,0.5);
        }
        .menu-title { font-family: 'Montserrat', sans-serif; font-size: 1.2rem; color: #fff; margin-bottom: 5px; text-transform: uppercase; }

        .btn {
            padding: 12px 20px; font-family: 'Montserrat', sans-serif; font-size: 1rem;
            border: none; border-radius: 8px; cursor: pointer; display: flex;
            align-items: center; justify-content: center; gap: 10px; font-weight: 600;
            transition: transform 0.1s;
        }
        .btn:active { transform: scale(0.98); }
        .btn-fav { background: #e91e63; color: white; }
        .btn-omit { background: #9e9e9e; color: #222; }
        .btn-close { background: #333; color: #fff; margin-top: 5px; }
        .btn-reload { background: #444; color: #fff; }
        .btn-warn { background: #d35400; color: #fff; }
        .btn-danger { background: #c0392b; color: #fff; }
        .btn-cancel { background: #555; color: #fff; }

        .setting-group { display: flex; flex-direction: column; gap: 8px; background: #222; padding: 12px; border-radius: 8px; }
        .setting-label { font-family: 'Montserrat', sans-serif; font-size: 0.9rem; color: #aaa; display: flex; justify-content: space-between; }
        
        /* IMPROVED TOUCH SLIDER CSS */
        input[type=range] { 
            width: 100%; 
            -webkit-appearance: none; appearance: none;
            height: 15px; background: #444; border-radius: 10px; outline: none; margin: 10px 0; cursor: pointer;
            touch-action: none; 
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none;
            width: 40px; height: 40px; border-radius: 50%; background: #f0f0f0; cursor: pointer;
            border: 2px solid #1a1a1a; box-shadow: 0 2px 5px rgba(0,0,0,0.5);
        }

        #delete-preview-img { max-width: 200px; max-height: 200px; border-radius: 8px; margin: 10px auto; border: 2px solid #c0392b; }
        .delete-msg { color: #aaa; font-size: 0.9rem; margin-bottom: 10px; }
    </style>
</head>
<body>

    <div id="app">
        <!-- New Full Screen Loader -->
        <div id="loader-overlay" class="visible">
            <div id="loader-text">Loading Memories...</div>
        </div>
        
        <div id="photo-container">
            <img id="main-photo" src="" alt="Memory">
        </div>

        <div id="text-overlay">
            <div id="content-wrapper">
                <div id="poem-text"></div>
                <div id="author-text"></div>
            </div>
            <div id="date-display"></div>
        </div>

        <!-- QUICK FAV ICON (Top Right) -->
        <div id="quick-fav">
            <svg viewBox="0 0 24 24">
                <path class="heart-outline" d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/>
                <path class="heart-fill" d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/>
            </svg>
        </div>

        <!-- CLICK ZONES -->
        <div id="zone-left" class="click-zone"></div>
        <div id="zone-center" class="click-zone"></div>
        <div id="zone-right" class="click-zone"></div>

        <!-- MENU -->
        <div id="menu-overlay">
            <div id="menu-box">
                <div class="menu-title">Control Panel</div>
                
                <div class="setting-group">
                    <div class="setting-label"><span>Speed</span><span id="interval-display">30s</span></div>
                    <input type="range" id="interval-slider" min="10" max="240" step="10" value="30">
                </div>

                <!-- Redundant Favorite button removed -->

                <button class="btn btn-omit" onclick="menuActions.omit()">
                    <span>üö´</span> Omit Photo
                </button>

                <button class="btn btn-danger" onclick="menuActions.confirmDelete()">
                    <span>üóëÔ∏è</span> Delete Photo
                </button>

                <div style="height: 1px; background: #333; margin: 5px 0;"></div>

                <button class="btn btn-warn" onclick="menuActions.reindex()"><span>‚ö†Ô∏è</span> Full Re-index</button>
                <button class="btn btn-reload" onclick="menuActions.reload()"><span>‚Üª</span> Reload App</button>
                <button class="btn btn-danger" onclick="menuActions.exit()"><span>‚èª</span> Exit App</button>
                <button class="btn btn-close" onclick="menuActions.close()">Close</button>
            </div>
        </div>

        <!-- DELETE CONFIRM -->
        <div id="delete-confirm-overlay">
            <div id="menu-box">
                <div class="menu-title" style="color:#c0392b">Delete Photo?</div>
                <div class="delete-msg">This cannot be undone.</div>
                <img id="delete-preview-img" src="" />
                
                <button class="btn btn-danger" onclick="menuActions.doDelete()">Confirm Delete</button>
                <button class="btn btn-cancel" onclick="menuActions.cancelDelete()">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        // --- CONFIG & STATE ---
        const DEFAULT_INTERVAL = 30000;
        let currentInterval = parseInt(localStorage.getItem('photo_interval')) || DEFAULT_INTERVAL;
        let nextMemoryPromise = null;
        let displayTimer = null;
        
        let currentMemory = null; 
        let historyStack = []; 
        const HISTORY_LIMIT = 25;
        
        // GLOBAL LOCK
        let isProcessing = false;

        // Elements
        const photoEl = document.getElementById('main-photo');
        const poemEl = document.getElementById('poem-text');
        const authorEl = document.getElementById('author-text');
        const dateEl = document.getElementById('date-display');
        
        const loaderOverlay = document.getElementById('loader-overlay');
        const loaderText = document.getElementById('loader-text');
        
        const quickFavBtn = document.getElementById('quick-fav');
        const menuOverlay = document.getElementById('menu-overlay');
        const deleteOverlay = document.getElementById('delete-confirm-overlay');
        const deletePreviewEl = document.getElementById('delete-preview-img');
        const sliderEl = document.getElementById('interval-slider');
        const intervalDisplayEl = document.getElementById('interval-display');

        // Init Slider
        sliderEl.value = currentInterval / 1000;
        intervalDisplayEl.innerText = `${sliderEl.value}s`;

        // --- UI HELPERS ---
        
        function showLoader(msg = "Loading...") {
            loaderText.innerText = msg;
            loaderOverlay.classList.add('visible');
        }

        function hideLoader() {
            loaderOverlay.classList.remove('visible');
        }

        // --- MOUSE AUTOHIDE ---
        let mouseTimer = null;
        document.addEventListener('mousemove', () => {
            // Optimization: Only touch style if needed
            if (document.body.style.cursor !== 'default') {
                document.body.style.cursor = 'default';
            }
            
            if (mouseTimer) clearTimeout(mouseTimer);
            mouseTimer = setTimeout(() => {
                // Only hide if menus are closed
                if (!menuOverlay.classList.contains('overlay-visible') && 
                    !deleteOverlay.classList.contains('overlay-visible')) {
                    document.body.style.cursor = 'none';
                }
            }, 2000);
        });

        // --- CORE LOGIC ---

        async function fetchNextMemory() {
            // TIMEOUT CONTROLLER (15 seconds)
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 15000);

            try {
                const response = await fetch('/api/next-memory', { signal: controller.signal });
                clearTimeout(timeoutId);
                
                if (!response.ok) throw new Error(`Server Error: ${response.status}`);
                const data = await response.json();

                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.src = `/api/image?path=${data.imagePathEncoded}`;
                    img.onload = () => resolve({ ...data, imageSrc: img.src });
                    img.onerror = () => reject("Image load failed");
                    
                    // Also timeout the image load itself
                    setTimeout(() => reject("Image load timed out"), 15000);
                });
            } catch (error) {
                console.error("Fetch failed:", error);
                throw error;
            }
        }

        function renderMemory(memory) {
            photoEl.src = memory.imageSrc;
            poemEl.innerText = `"${memory.text}"`;
            
            // Update Heart Icon based on API response
            if (memory.isFavorite) quickFavBtn.classList.add('active');
            else quickFavBtn.classList.remove('active');

            if (memory.type === 'quote' && memory.author) {
                authorEl.innerText = memory.author === 'System Alert' ? memory.author : `- ${memory.author}`;
                authorEl.style.display = 'block';
                
                // Red text for errors
                if (memory.author === 'System Alert') {
                    poemEl.style.color = '#ff6b6b'; authorEl.style.color = '#ff6b6b';
                } else {
                    poemEl.style.color = '#f0f0f0'; authorEl.style.color = '#aaa';  
                }
            } else {
                authorEl.style.display = 'none';
                poemEl.style.color = '#f0f0f0';
            }

            const dateObj = new Date(memory.date);
            if (dateObj.getFullYear() > 1980) {
                dateEl.innerText = dateObj.toLocaleDateString('pt-PT', { year: 'numeric', month: 'long', day: 'numeric' }).toUpperCase();
            } else {
                dateEl.innerText = ""; 
            }
        }

        async function updateDisplay(useHistory = false) {
            if (isProcessing) return;
            isProcessing = true; 

            try {
                if (displayTimer) clearTimeout(displayTimer);

                // Show loader if manually navigating
                if (!nextMemoryPromise && !useHistory) {
                    showLoader("Loading...");
                }

                let memory;
                if (useHistory && historyStack.length > 0) {
                    memory = historyStack.pop();
                    nextMemoryPromise = null; 
                } else {
                    if (!nextMemoryPromise) nextMemoryPromise = fetchNextMemory();
                    
                    if (currentMemory) {
                        historyStack.push(currentMemory);
                        if (historyStack.length > HISTORY_LIMIT) historyStack.shift();
                    }
                    
                    memory = await nextMemoryPromise;
                }

                currentMemory = memory;

                // Animate Swap
                photoEl.style.opacity = 0;
                poemEl.style.opacity = 0;
                authorEl.style.opacity = 0;
                dateEl.style.opacity = 0;
                
                await new Promise(r => setTimeout(r, 800)); 

                renderMemory(memory);
                hideLoader();

                photoEl.style.opacity = 1;
                poemEl.style.opacity = 1;
                if (memory.type === 'quote') authorEl.style.opacity = 1;
                dateEl.style.opacity = 1;

                // Queue next
                nextMemoryPromise = fetchNextMemory().catch(e => console.warn("Background fetch failed, will retry later"));
                displayTimer = setTimeout(updateDisplay, currentInterval);

            } catch (error) {
                console.error("Display update failed:", error);
                
                // If we failed, show visual feedback so user knows it's not just "stuck"
                showLoader("Retrying Connection...");
                
                // Clear promise to force fresh fetch next time
                nextMemoryPromise = null;
                displayTimer = setTimeout(updateDisplay, 5000);
                
            } finally {
                // CRITICAL: Always unlock the UI
                isProcessing = false;
            }
        }

        // --- NAVIGATION HANDLERS ---

        document.getElementById('zone-left').addEventListener('click', () => {
            if (menuOverlay.classList.contains('overlay-visible') || isProcessing) return;
            if (historyStack.length === 0) return; 
            updateDisplay(true); 
        });

        document.getElementById('zone-center').addEventListener('click', () => {
            if (isProcessing) return;
            if (displayTimer) clearTimeout(displayTimer); 
            menuOverlay.classList.add('overlay-visible');
        });

        document.getElementById('zone-right').addEventListener('click', () => {
            if (menuOverlay.classList.contains('overlay-visible') || isProcessing) return;
            // Visual feedback
            showLoader("Loading...");
            updateDisplay(false); 
        });

        // --- MENU & ACTIONS ---

        menuOverlay.addEventListener('click', (e) => { 
            if (e.target === menuOverlay) menuActions.close(); 
        });
        
        sliderEl.addEventListener('input', (e) => {
            const seconds = e.target.value;
            intervalDisplayEl.innerText = `${seconds}s`;
            currentInterval = seconds * 1000;
            localStorage.setItem('photo_interval', currentInterval);
        });

        // Quick Fav Icon Logic
        quickFavBtn.addEventListener('click', (e) => {
            // Prevent event from bubbling down to navigation zones
            e.stopPropagation();
            menuActions.favorite();
        });

        const menuActions = {
            close: () => {
                menuOverlay.classList.remove('overlay-visible');
                if (displayTimer) clearTimeout(displayTimer);
                displayTimer = setTimeout(updateDisplay, currentInterval);
            },
            
            favorite: async () => {
                if (!currentMemory || isProcessing) return;
                isProcessing = true;
                
                // Visual feedback immediate
                showLoader(quickFavBtn.classList.contains('active') ? "Removing..." : "Favoriting...");
                
                try {
                    const res = await fetch('/api/favorite', {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({ currentPath: decodeURIComponent(currentMemory.imagePathEncoded) })
                    });
                    const data = await res.json();
                    
                    hideLoader();
                    isProcessing = false;

                    if (data.success) {
                        // Toggle UI immediately
                        if (data.isFavorite) quickFavBtn.classList.add('active');
                        else quickFavBtn.classList.remove('active');
                        
                        // Update current memory state
                        currentMemory.isFavorite = data.isFavorite;
                        currentMemory.imagePathEncoded = encodeURIComponent(data.newPath);
                        
                        // If menu was open, close it
                        if (menuOverlay.classList.contains('overlay-visible')) menuActions.close();
                    } else alert("Error: " + (data.error || "Unknown"));
                } catch(e) { 
                    hideLoader();
                    isProcessing = false;
                    alert("Failed to favorite."); 
                }
            },

            omit: async () => {
                if (!currentMemory || isProcessing) return;
                // Removed confirmation dialog here
                
                isProcessing = true;
                showLoader("Omitting...");
                
                try {
                    const res = await fetch('/api/omit', {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({ currentPath: decodeURIComponent(currentMemory.imagePathEncoded) })
                    });
                    
                    if (res.ok) {
                        menuActions.close();
                        nextMemoryPromise = null;
                        isProcessing = false;
                        updateDisplay(false);
                    } else {
                        const err = await res.json();
                        hideLoader();
                        isProcessing = false;
                        alert("Failed: " + err.error);
                    }
                } catch(e) {
                    hideLoader();
                    isProcessing = false;
                    alert("Error omitting.");
                }
            },

            confirmDelete: () => {
                if (!currentMemory) return;
                menuOverlay.classList.remove('overlay-visible'); 
                deletePreviewEl.src = currentMemory.imageSrc;
                deleteOverlay.classList.add('overlay-visible');
            },

            cancelDelete: () => {
                deleteOverlay.classList.remove('overlay-visible');
                displayTimer = setTimeout(updateDisplay, currentInterval);
            },

            doDelete: async () => {
                if (!currentMemory || isProcessing) return;
                isProcessing = true;
                showLoader("Deleting...");
                
                try {
                    const res = await fetch('/api/photo', {
                        method: 'DELETE',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({ currentPath: decodeURIComponent(currentMemory.imagePathEncoded) })
                    });
                    
                    if (res.ok) {
                        deleteOverlay.classList.remove('overlay-visible');
                        
                        nextMemoryPromise = null; 
                        isProcessing = false; 
                        // Force immediate update
                        updateDisplay(false); 
                    } else {
                        const err = await res.json();
                        hideLoader();
                        isProcessing = false;
                        alert("Failed: " + err.error);
                    }
                } catch(e) { 
                    hideLoader();
                    isProcessing = false;
                    alert("Error deleting."); 
                }
            },

            reindex: async () => {
                if (confirm("Re-index?")) {
                    menuActions.close();
                    showLoader("Re-indexing...");
                    try { await fetch('/api/reindex', { method: 'POST' }); } catch (e) {}
                    // Hide loader after a few seconds, index runs in bg
                    setTimeout(() => hideLoader(), 5000);
                }
            },
            reload: () => window.location.reload(),
            exit: async () => {
                if (confirm("Exit?")) {
                    showLoader("Shutting Down...");
                    await fetch('/api/exit', { method: 'POST' });
                }
            }
        };

        // Start App
        updateDisplay();
    </script>
</body>
</html>